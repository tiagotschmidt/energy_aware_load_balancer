import time
import socket
import os
import sys
import logging
import argparse
import random
import csv

# --- Configuration ---
SWITCH_IP = "127.0.0.1"
PORT = 50001
INTERVAL = 0.5         
# BENCHMARK_SCORE is no longer needed for direct throughput calc, 
# but you might keep it if you want to normalize the score.
# For pure Throughput/Watt, we don't need it.

RAPL_FILE = "../rapl/rapl_value.txt"
LOG_DIR = "../sift/logs"

logging.basicConfig(level=logging.INFO, format='%(asctime)s [%(levelname)s] %(message)s')

def get_cpu_utilization(cpu_core: str, prev_idle, prev_total):
    """
    Reads /proc/stat. Returns: (util_percent, curr_idle, curr_total)
    """
    try:
        curr_idle = 0
        curr_total = 0
        found = False

        with open('/proc/stat', 'r') as f:
            for line in f:
                parts = line.split()
                if parts[0].startswith('cpu') and len(parts[0]) > 3:
                    core_id = parts[0][3:]
                    if core_id == cpu_core:
                        metrics = list(map(int, parts[1:]))
                        curr_idle = metrics[3] + metrics[4]
                        curr_total = sum(metrics)
                        found = True
                        break
        
        if not found:
             with open('/proc/stat', 'r') as f:
                line = f.readline() 
                metrics = list(map(int, line.split()[1:]))
                curr_idle = metrics[3] + metrics[4]
                curr_total = sum(metrics)

        diff_idle = curr_idle - prev_idle
        diff_total = curr_total - prev_total
        
        if diff_total == 0: return 0.0, curr_idle, curr_total

        util = 100.0 * (1.0 - (diff_idle / diff_total))
        return max(0.0, util), curr_idle, curr_total

    except Exception as e:
        logging.error(f"CPU Read Error: {e}")
        return 0.0, prev_idle, prev_total

def get_energy_joules():
    """Reads Intel RAPL energy counter."""
    try:
        with open( RAPL_FILE , "r") as f:
            return int(f.read()) / 1000000.0 
    except (ValueError, FileNotFoundError):
        return None

def get_real_throughput(host_name):
    """Reads the throughput file generated by the UDP server."""
    filename = f"{LOG_DIR}/{host_name}_throughput.txt"
    try:
        if os.path.exists(filename):
            with open(filename, 'r') as f:
                val = f.read().strip()
                return float(val) if val else 0.0
    except Exception:
        pass
    return 0.0

def calculate_energy_efficiency(throughput, power):
    """
    New Algorithm: Efficiency = Throughput (Req/sec) / Power (Watts)
    """
    if throughput <= 0: 
        return power # Avoid division by zero, though power > 0 usually
    return power / throughput

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("host_name", help="Name of this host (e.g., h2)")
    parser.add_argument("cpu_core", help="Pinned CPU Core ID (e.g., 0)")
    parser.add_argument("--efficiency", type=float, default=1.0, help="Hardware Profile Factor")
    
    args = parser.parse_args()
    startup_efficiency = args.efficiency

    if not os.path.exists(LOG_DIR): os.makedirs(LOG_DIR)
    csv_file = f"{LOG_DIR}/{args.host_name}_energy.csv"
    
    # Initialize CSV
    with open(csv_file, 'w', newline='') as f:
        writer = csv.writer(f)
        writer.writerow(["timestamp", "host", "cpu_util", "throughput_rps", "power_watts", "efficiency_score"])
    
    logging.info(f"Agent {args.host_name} Started. Metric: Throughput/Power")

    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    
    _, prev_idle, prev_total = get_cpu_utilization(args.cpu_core, 0, 0)
    prev_energy = get_energy_joules()
    prev_time = time.time()
    
    try:
        while True:
            time.sleep(INTERVAL)
            
            # 1. CPU Metrics (Still useful for logging/fallback)
            util, curr_idle, curr_total = get_cpu_utilization(args.cpu_core, prev_idle, prev_total)
            
            # 2. Throughput Metric (From Server File)
            throughput = get_real_throughput(args.host_name)

            # 3. Energy / Power
            curr_energy = get_energy_joules()
            curr_time = time.time()
            time_delta = curr_time - prev_time
            
            if curr_energy is not None and prev_energy is not None:
                energy_delta = max(0, curr_energy - prev_energy)
                raw_power = energy_delta / time_delta
                mode = "REAL"
            else:
                # Fallback Simulation: 
                # Base 10W + dynamic based on util
                raw_power = 10.0 + (util * 0.5)
                mode = "SIM"

            # Apply Hardware Factor (simulating different hardware generations)
            profiled_power = raw_power * startup_efficiency

            # 4. Calculate Score: Throughput / Power
            score = calculate_energy_efficiency(throughput, profiled_power)

            # --- 5. LOG TO CSV ---
            with open(csv_file, 'a', newline='') as f:
                writer = csv.writer(f)
                writer.writerow([curr_time, args.host_name, f"{util:.2f}", f"{throughput:.2f}", f"{profiled_power:.2f}", f"{score:.2f}"])

            # 6. Send Telemetry to Switch
            # Format: ID, Score, Utilization (optional util for debug)
            message = f"{args.host_name},{score:.4f},{util:.2f}"
            try:
                sock.sendto(message.encode(), (SWITCH_IP, PORT))
                logging.info(f"[{mode}] Sent: {message} | Score: {score:.3f} | Thrpt: {throughput:.1f} | Pwr: {profiled_power:.1f}W")
            except Exception as e:
                logging.error(f"UDP Error: {e}")

            # 7. Update State
            prev_idle, prev_total = curr_idle, curr_total
            prev_energy = curr_energy
            prev_time = curr_time

    except KeyboardInterrupt:
        logging.info("Agent shutting down.")
        sock.close()

if __name__ == "__main__":
    main()